{"version":3,"file":"public/js/dist/galactron/actions/animation-action.js","sources":["public/js/dist/galactron/actions/animation-action.js","@traceur/generated/TemplateParser/1","@traceur/generated/TemplateParser/3","@traceur/generated/TemplateParser/2","@traceur/generated/TemplateParser/5","@traceur/generated/TemplateParser/4"],"names":[],"mappings":"AAKA;ACLI,CAAJ,EAAI,CAAA,YAAY,sDAAoB,CAAC;ACAjC,CAAJ,EAAI,kBFKJ,SAAM,gBAAe,CAER,aAAa,AAAY,CACrC;KAD0B,KAAI,6CAAG,KAAI;AGPtC,CHSE,gBGTa,UAAU,qDAC4B,CHQ3C;AACR,CAAA,KAAI,cAAc,EAAG,cAAa,CAAC;AACnC,CAAA,KAAI,KAAK,EAAG,KAAI,CAAC;CEXsB,AFYvC,CEZuC;AEArC,CAAJ,EAAI,mCAAqC,CAAA;ACAzC,CAAA,AAAC,eAAe,YAAY,CAAC;CLmB5B,MAAK,CAAL,UAAM,CACN;AGpBD,CHqBE,kBGrBa,UAAU,+CAC4B,CHoBrC;AACd,CAAA,SAAM,KAAK,CAAC,aAAa,CAAC,CAAC;CAE3B,OAAG,IAAI,CAAC;AACP,CAAA,WAAM,qBAAqB,CAAC,aAAa,CAAC,CAAC;KAC3C,KAAM;AACN,CAAA,WAAM,EAAE,CAAC;KACT;CAAA,EACD;CAMD,cAAa,CAAb,UAAc,oBAAoB,CAAC,CAAA,YAAY,CAAC,CAAA,iBAAiB,CACjE;CACC,OAAI,CAAC,OAAO,CAAA,EAAI,SAAQ,CAAE;CACzB,YAAO;KACP;AACD,CADC,OACG,oBAAoB,GAAI,cAAa,CAAE;AAAC,CAAA,qBAAgB,EAAG,CAAA,MAAM,oBAAoB,EAAE,CAAC;CAE3F,SAAI,YAAY,GAAI,EAAC,gBAAgB,OAAO,OAAO,EAAG,EAAC,CAAC,CAAE;AACzD,CAAA,WAAI,OAAO,EAAE,CAAC;AACd,CAAA,eAAQ,EAAG,KAAI,CAAC;OAEhB;CAAA,IACD;CAAA,EACD;CAAA,KA3C4B,OAAM,CKJqB;CLiDzD","sourcesContent":["/**\r\n * This action simply plays the specified animation and then finishes\r\n * \r\n * @author Garcia Hurtado\r\n */\r\nclass AnimationAction extends Action \r\n{\r\n\tconstructor(animationName,wait = true) \r\n\t{\r\n\t\tsuper();\r\n\t\tthis.animationName = animationName;\r\n\t\tthis.wait = wait;\r\n\t}\r\n\t\r\n\t/**\r\n\t * When the animation starts, we check whether we should wait until it completes all\r\n\t * frames before starting the next action. If the action shouldn't wait, we finish() the \r\n\t * action right away. If it should wait, we add a callback to check for the animation to end\r\n\t */\r\n\tstart()\r\n\t{\r\n\t\tsuper.start();\r\n\t\ttarget.play(animationName);\r\n\r\n\t\tif(wait){\r\n\t\t\ttarget.addAnimationCallback(checkFinished);\r\n\t\t} else {\r\n\t\t\tfinish();\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check whether the animation has finished, and if so, finish the action to that\r\n\t * the next action can start\r\n\t */\r\n\tcheckFinished(currentAnimationName,currentFrame,currentFrameIndex)\r\n\t{\r\n\t\tif (!running || finished) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (currentAnimationName == animationName) {currentAnimation = target.getCurrentAnimation();\r\n\t\t\t\r\n\t\t\tif (currentFrame == (currentAnimation.frames.length - 1)) {\r\n\t\t\t\tthis.finish();\r\n\t\t\t\tfinished = true; // mark finished right away to avoid double firing the delayed finish() call\r\n\t\t\t\t//Utils.doLater(currentAnimation.delay * 1000, this.finish); // why this??\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","var __moduleName = $__placeholder__0;","var $__placeholder__0 = $__placeholder__1","$traceurRuntime.superCall($__placeholder__0, $__placeholder__1, $__placeholder__2,\n                                   $__placeholder__3)","var $__placeholder__0 = $__placeholder__1","($traceurRuntime.createClass)($__placeholder__0, $__placeholder__1, $__placeholder__2,\n                                       $__placeholder__3)"]}