{"version":3,"file":"public/js/dist/galactron/actions/follow-action.js","sources":["public/js/dist/galactron/actions/follow-action.js","@traceur/generated/TemplateParser/1","@traceur/generated/TemplateParser/3","@traceur/generated/TemplateParser/7","@traceur/generated/TemplateParser/5","@traceur/generated/TemplateParser/4"],"names":[],"mappings":"AAKC;ACLG,CAAJ,EAAI,CAAA,YAAY,mDAAoB,CAAC;ACAjC,CAAJ,EAAI,eFKH,SAAM,aAAY;AGLnB,CAAA,gBAAe,iBAAiB,CAAC,IAAI,CACrB,wBAA2B,CAAE,UAAS,CAAC,CAAA;CDDd,AF+EvC,CE/EuC;AEArC,CAAJ,EAAI,6BAAqC,CAAA;ACAzC,CAAA,AAAC,eAAe,YAAY,CAAC;CLa3B,aAAY,CAAZ,UAAa,MAAM,CAAC,CAAA,QAAQ,AAAwB,CACpD;OAD6B,QAAO,6CAAG,EAAC;OAAC,QAAO,6CAAG,EAAC;AAEnD,CAAA,OAAI,OAAO,EAAG,OAAM,CAAC;AACrB,CAAA,OAAI,SAAS,EAAG,SAAQ,CAAC;GACzB;CAED,OAAM,CAAN,UAAO,CACP;CAEC,OAAI,aAAa,EAAG,YAAW,CAAE;AAChC,CAAA,kBAAa,GAAI,CAAA,IAAI,QAAQ,CAAC;CAC9B,YAAO;KACP;AACD,CADC,WACO,EAAG,OAAM,CAAC;CAElB,OAAI,QAAQ,WAAW,CAAC,QAAQ,CAAC,CAAA,CAAG,QAAO,CAAE,GAE5C,KAAM,GAIN;AACD,CADC,gBACY,EAAG,CAAA,MAAM,QAAQ,CAAC,QAAQ,CAAC,CAAC;AACzC,CAAA,UAAO,EAAG,CAAA,MAAM,WAAW,EAAG,CAAA,IAAI,QAAQ,CAAC;CAG3C,OAAI,OAAO,EAAG,cAAa,CAAE;AAC5B,CAAA,WAAM,KAAK,CAAC,aAAa,CAAC,CAAC;KAC3B,KAAM;AACN,CAAA,WAAM,KAAK,CAAC,OAAO,CAAC,CAAC;KACrB;AAED,CAFC,gBAEY,EAAG,EAAC,CAAC;CAClB,UAAO;GACP;CAED,WAAU,CAAV,UAAW,CAAC;AACX,CAAA,gBAAa,EAAG,CAAA,MAAM,QAAQ,CAAC,QAAQ,CAAC,CAAC;AACzC,CAAA,gBAAa,EAAG,CAAA,aAAa,EAAG,EAAC,CAAC,EAAG,CAAA,IAAI,GAAG,CAAC,CAAC;CAG9C,OAAI,IAAI,IAAI,CAAC,SAAS,CAAC,CAAA,CAAG,IAAG,CAAE;CAC9B,YAAO;KACP;AAED,CAFC,OAEG,aAAa,EAAG,CAAA,IAAI,GAAG,CAAC,GAE3B,KAAM,KAAI,aAAa,EAAG,EAAC,IAAI,GAAG,CAAE,GAEpC;AAID,CAJC,OAIG,SAAS,EAAG,CAAA,IAAI,IAAI,CAAC,aAAa,CAAC,CAAE;AACxC,CAAA,cAAS,EAAG,CAAA,IAAI,IAAI,CAAC,aAAa,CAAC,CAAC;KACpC;AAED,CAFC,OAEG,MAAM,YAAY,EAAG,cAAa,CAAE;AACvC,CAAA,SAAI,IAAI,CAAC,uBAAuB,CAAC,CAAC;AAClC,CAAA,WAAM,KAAK,CAAC,MAAM,YAAY,EAAG,UAAS,CAAC,CAAC;KAC5C,KAAO;AACP,CAAA,SAAI,IAAI,CAAC,uBAAuB,CAAC,CAAC;AAClC,CAAA,WAAM,KAAK,CAAC,MAAM,YAAY,EAAG,UAAS,CAAC,CAAC;KAC5C;CAAA,EAED;CAAA,KAzEyB,OAAM,CKJuB;CL+EzD","sourcesContent":["\t/**\r\n\t * Used to make a sprite follow another\r\n\t *\r\n\t * @author Garcia Hurtado\r\n\t */\r\n\tclass FollowAction extends Action \r\n\t{\r\n\t\t//followed;minDist;maxDist;\r\n\t\t\r\n\t\t//followElapsed = 0;\r\n\t\t\r\n\t\t// time to wait between two trajectory adjustments (in seconds)followDelay = 0.2; \r\n\t\t\r\n\t\tFollowAction(target,followed,minDist = 0,maxDist = 0) \r\n\t\t{\r\n\t\t\tthis.target = target;\r\n\t\t\tthis.followed = followed;\r\n\t\t}\r\n\t\t\r\n\t\tupdate()\r\n\t\t{\r\n\t\t\t// only turn every certain number of update cycles\r\n\t\t\tif (followElapsed < followDelay) {\r\n\t\t\t\tfollowElapsed += FlxG.elapsed;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tmyTarget = target;\r\n\t\t\t\r\n\t\t\tif (myTarget.distanceTo(followed) < minDist) {\r\n\t\t\t\t//target.speed = 20;\r\n\t\t\t} else {\r\n\t\t\t\t//target.speed = 100;\r\n\t\t\t\t//target.velocity.y = followed.velocity.y;\r\n\t\t\t\t//target.x = followed.x + 10;\r\n\t\t\t}\r\n\t\t\tangleToTarget = target.angleTo(followed);\r\n\t\t\tmaxTurn = target.maxAngular * FlxG.elapsed;\r\n\t\t\t\r\n\t\t\t// always turn to face the sprite we are following\r\n\t\t\tif (maxTurn > angleToTarget) {\r\n\t\t\t\ttarget.turn(angleToTarget);\r\n\t\t\t} else {\r\n\t\t\t\ttarget.turn(maxTurn);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfollowElapsed = 0;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tturnTarget(){\r\n\t\t\tangleToTarget = target.angleTo(followed);\r\n\t\t\tangleToTarget = angleToTarget % (2 * Math.PI); // limit angle to +PI / -turnAngle = target.maxAngular * FlxG.elapsed;\r\n\t\t\t\r\n\t\t\t// do not modify the trajectory if the difference is too small, to avoid jitter\r\n\t\t\tif (Math.abs(turnAngle) < 0.1) { \r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (angleToTarget > Math.PI){\r\n\t\t\t\t//angleToTarget -= 2*Math.PI;\r\n\t\t\t} else if (angleToTarget < -Math.PI) {\r\n\t\t\t\t//angleToTarget += 2*Math.PI;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// avoid overshooting the turn\r\n\t\t\tif (turnAngle > Math.abs(angleToTarget)) { \r\n\t\t\t\tturnAngle = Math.abs(angleToTarget);\r\n\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\tif (target.facingAngle > angleToTarget) { // we must increase the angle to face the target\r\n\t\t\t\tFlxG.log(\"facing angle > target\");\r\n\t\t\t\ttarget.turn(target.facingAngle - turnAngle);\r\n\t\t\t}  else { // we must decrease the angle to face the target\r\n\t\t\t\tFlxG.log(\"facing angle < target\");\r\n\t\t\t\ttarget.turn(target.facingAngle + turnAngle);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n","var __moduleName = $__placeholder__0;","var $__placeholder__0 = $__placeholder__1","$traceurRuntime.defaultSuperCall(this,\n                $__placeholder__0.prototype, arguments)","var $__placeholder__0 = $__placeholder__1","($traceurRuntime.createClass)($__placeholder__0, $__placeholder__1, $__placeholder__2,\n                                       $__placeholder__3)"]}