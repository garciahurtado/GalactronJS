{"version":3,"file":"src","sources":["src","@traceur/generated/TemplateParser/1","@traceur/generated/TemplateParser/2","@traceur/generated/TemplateParser/4","@traceur/generated/TemplateParser/3"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * An ActionChain is a manager of actions which can store a list of actions, run them in sequence,\r\n * and retrieve them by name. The action chain can be started, stopped and restarted.\r\n * \r\n * The ActionChain can also be added to another chain as you would add an action, to provide action\r\n * tree branching.\r\n * \r\n * ActionChains can be initialized with a target object, which will be passed to all of the chain's\r\n * actions as the default target for actions to modify.\r\n * \r\n * @author Garcia Hurtado\r\n */\r\n\r\nvar ActionChain = function(target) {\r\n\tAction.call(this, target);\r\n\r\n\tthis.actions = new Array();\r\n\tthis.actionRegistry = new Array();\r\n\tthis.running = false;\r\n}\r\n\r\n/**\r\n * Adds an action and triggers it when the previous one finishes. If the optional \r\n * name is provided, it also adds it to the named action registry\r\n * @param\taction\r\n * @param\tname\r\n */\r\nActionChain.prototype.chainAction = function(newAction, name){\r\n\tname = name || null;\r\n\t\r\n\t// Unless this is the first action in the chain, link this new action to the onFinish event\r\n\t// of the previous one, so that it starts as soon as the previous one ends\r\n\tif(this.actions.length > 0){\r\n\t\tvar previousAction = actions[actions.length - 1];\r\n\t\t\r\n\t\tif (previousAction) {\r\n\t\t\tvar nextAction = newAction;\r\n\t\t\tpreviousAction.onFinish(function() {\r\n\t\t\t\tnextAction.start();\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\t\r\n\tthis.addAction(newAction, name);\r\n\t\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * Adds an action to the list, without chaining it.\r\n * @param\tnewAction\r\n * @param\tname\r\n * @return\r\n */\r\nActionChain.prototype.addAction = function(newAction, name){\r\n\t// Only add the target from the ActionChain if no target was previously set\r\n\tif (!newAction.target && ActionChain.prototype.target) {\r\n\t\tnewAction.target = ActionChain.prototype.target;\r\n\t}\r\n\t\r\n\tthis.actions.push(newAction);\r\n\tif(name){\r\n\t\tthis.actionRegistry[name] = newAction;\r\n\t}\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * If the action chain is currently stopped, it starts the first action in the chain. Otherwise, it has no effect\r\n */\r\nActionChain.prototype.start = function(){\r\n\tthis.reset();\r\n\tif(this.actions[0]){\r\n\t\tthis.actions[0].start();\r\n\t\tthis.running = true;\t\r\n\t}\r\n}\r\n\r\n/**\r\n * As long as the Action Chain is running, update all the actions in the chain which are currently running\r\n */\r\nActionChain.prototype.update = function(){\r\n\tif (!this.running) {\r\n\t\treturn;\r\n\t} else {\r\n\t\tfor (var action in this.actions) {\r\n\t\t\tif(action.running){\r\n\t\t\t\taction.update();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Stops all actions in the chain\r\n */\r\nActionChain.prototype.stopAll = function(){\r\n\tfor (var action in this.actions) {\r\n\t\taction.stop();\r\n\t}\r\n\tthis.running = false;\r\n}\r\n\r\n/**\r\n * Stops all currently running actions on this chain and starts the action specified\r\n * @param\tactionName\r\n */\r\nActionChain.prototype.switchTo = function(actionName){\r\n\tstopAll();\r\n\tthis.actionRegistry[actionName].start();\r\n\tthis.running = true;\r\n}\r\n\r\n/**\r\n * Stops all running actions and resets them to their original state\r\n */\r\nActionChain.prototype.reset = function(){\r\n\tthis.running = false;\r\n\tfor (var action in actions) {\r\n\t\taction.init();\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns the action from the registry that matches the name provided\r\n * \r\n * @param\tactionName\r\n * @return\r\n */\r\nActionChain.prototype.getAction = function(actionName){\r\n\tif (this.actionRegistry[actionName] != null) {\r\n\t\treturn this.actionRegistry[actionName];\r\n\t} else {\r\n\t\tthrow new Error(\"There is no action named \" + actionName);\r\n\t}\r\n}\r\n\r\n;/**\r\n* Base behavior class to be extended in custom behaviors that modify sprite motions and\r\n* execute time-based actions with each update cycle of the sprite.\r\n* \r\n* An action is stopped when first created, until explicitly started with start().\r\n* \r\n* An action can have a \"Target\", which is simply an object upon which the action effects\r\n* its influence (such as modifying the coordinates of a sprite to cause movement). Not\r\n* all actions will have an explicit target.\r\n* \r\n* @author Garcia\r\n*/\r\nclass Action {\r\n\tconstructor(target = null){\r\n\t\tthis.target = target;\r\n\t\tthis.running;\r\n\t\tthis.finished;\r\n\t\tthis.finishHandler;\r\n\r\n\t\tAction.init.call(this);\r\n\t}\r\n\r\n\tinit(){\r\n\t\tthis.running = false;\r\n\t\tthis.finished = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Called to update the actions of the controlled sprite once per game tick. \r\n\t * Override to provide custom behaviors.\r\n\t */\r\n\tupdate() {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Revive the FlxBasic object so that it will continue to update\r\n\t */\r\n\tstart()\r\n\t{\r\n\t\tthis.running = true;\r\n\t\tfinished = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Stop running the action.\r\n\t * @return\r\n\t */\r\n\tstop()\r\n\t{\r\n\t\tthis.running = false;\r\n\t\tthis.finished = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Stops executing the action and calls the finish handler, if one is set.\r\n\t */\r\n\tfinish()\r\n\t{\r\n\t\tthis.stop();\r\n\t\t\r\n\t\tif (this.finishHandler != null) {\r\n\t\t\tthis.finishHandler();\r\n\t\t}\r\n\t\t\r\n\t\tthis.init();\r\n\t}\r\n\r\n\t/**\r\n\t * Register a function to be executed when the action is finished\r\n\t */\r\n\tonFinish(handler)\r\n\t{\r\n\t\tthis.finishHandler = handler;\r\n\t}\r\n}\r\n","var __moduleName = $__placeholder__0;","var $__placeholder__0 = $__placeholder__1","var $__placeholder__0 = $__placeholder__1","($traceurRuntime.createClass)($__placeholder__0, $__placeholder__1, $__placeholder__2)"]}